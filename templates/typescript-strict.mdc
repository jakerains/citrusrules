---
description:
globs:
alwaysApply: false
---
# TypeScript Strict Mode Standards

## Type Safety Requirements

- NEVER use `any` type - use `unknown` for truly unknown types
- Define explicit return types for all functions
- Use strict null checks - handle `undefined` and `null` explicitly
- Prefer `interface` for object shapes, `type` for unions/intersections
- Use type guards instead of type assertions
- Implement proper generic constraints

## Interface and Type Definitions

- Prefer `interface` for object shapes that might be extended
- Use `type` for unions, intersections, and computed types
- Define generic constraints to improve type safety
- Use branded types for domain-specific primitives
- Implement proper error types instead of throwing strings

## Advanced Patterns

- Use conditional types for complex type transformations
- Implement mapped types for systematic transformations
- Leverage template literal types for string manipulation
- Use utility types (`Pick`, `Omit`, `Partial`, etc.) appropriately

## Examples

### Good: Strict typing
```typescript
interface User {
  id: string;
  name: string;
  email?: string;
}

function getUser(id: string): Promise<User | null> {
  // Implementation
}

function isUser(obj: unknown): obj is User {
  return typeof obj === 'object' && obj !== null && 'id' in obj;
}
```

### Bad: Loose typing
```typescript
// DON'T DO THIS
function getUser(id: any): any {
  return fetch(`/users/${id}`).then(r => r.json());
}
```
